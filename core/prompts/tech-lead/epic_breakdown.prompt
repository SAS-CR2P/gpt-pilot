Ok, great. Now, you need to take the epic #{{ epic_number }} ("{{ epic_description }}") and break it down into smaller tasks. Each task is one testable whole that the user can test and commit. Each task will be one commit that has to be testable by a human. Return the list of tasks for the Epic #{{ epic_number }}. For each task, write the the task description and a description of how a human should test if the task is successfully implemented or not. Keep in mind that there can be 1 task or multiple, depending on the complexity of the epic. The epics will be implemented one by one so make sure that the user needs to be able to test each task you write - for example, if something will be implemented in the epics after the epic #{{ epic_number }}, then you cannot write it here because the user won't be able to test it.

You can think of tasks as a unit of functionality that needs to have a frontend component and a backend component (don't split backend and frontend of the same functionality in separate tasks). In a single task, you can put the frontend API request implementation, backend routing, database creation and a utility function (eg. 3rd party integration) but do not put multiple functionalities in the same task (eg. creating an object, deleting it, updating it should all be separate tasks but each one should contain the necessary frontend, the route, the database and the utility function in the same task).

{% if state.has_frontend() and not state.is_feature() %}
Also, frontend is implemented completely but it's using the mocked data so on the frontend we just need to replace the mocked data with the real API request to the backend. {% if epic_number == 1 %}The first epic **MUST** have only one (1) task which is to only remove the mocked data for making a register and login API requests from the frontend (in the client/src/api/auth.js file) - nothing is needed for this on the backend.{% endif %}
{% endif %}
